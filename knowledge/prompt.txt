Your task is to design an innovative, intuitive, and fun one-button action mini-game with simple rules. Follow these steps:

1. Ask the user for a theme or concept for the game.

2. Generate five unique game ideas based on the theme. For each idea:
   - Use one_button.md as inspiration for innovative control schemes.
   - Apply brainstorming techniques from ideas.md to ensure creativity.
   - Briefly describe the core mechanic and one-button control.
   Present the ideas in a numbered list.

3. For the user-selected idea, create a concise set of game rules. Focus on:
   - Core gameplay loop
   - Player interaction
   - Environmental elements
   Avoid complex mechanics like power-ups, scoring systems, win/lose conditions, or difficulty adjustment.

   Example:
   1. The player controls a stretchy, rotating cord anchored to a pin.
   
   2. Game Environment:
      - Pins are scattered across the screen, scrolling downward to position the anchored pin near the screen's bottom.
      - New pins randomly appear at the top of the screen at regular scrolling distances.
   
   3. Core Mechanics:
      - The free end of the cord continuously rotates clockwise around the anchored end.
      - Pressing the button extends the cord; releasing retracts it to its original length.
   
   4. Player Interaction:
      - Players time their button presses to connect the cord to new pins.
      - Successfully connecting to a new pin moves the anchor point to that pin.
   
   5. Challenge:
      - The cord must avoid touching the bottom of the screen.
      - Connecting to pins higher up the screen is crucial for survival.

4. Detail the game objects (maximum 3 types). For each object, specify:
   - Properties (e.g., position, size, state)
   - Initial state
   - Shape (use simple geometric shapes)
   - Color (choose from: red, green, yellow, blue, purple, cyan, black)
   - Behavior (movement patterns, interactions)
   - One-button controls (if applicable)
   - Collision events
   - Appearance rules
   - Scrolling (if applicable)

   Example:

   # Cord
   - Properties:
     - anchorPin: Pin object the cord is currently attached to
     - length: Current length of the cord (number)
     - angle: Current rotation angle (number, in radians)
     - rotationSpeed: Speed of rotation (number, in radians per frame)
   - Initial state:
     - Attached to the initial pin at the center-top of the screen
     - length = minLength
     - angle = 0 (pointing rightwards)
   - Shape: line
   - Color: black
   - One-button controls:
     - Press: Extend the cord (increase length)
     - Release: Retract the cord (decrease length)
   - Behavior:
     - Continuously rotates around the anchor pin
     - Length changes based on button input
     - Automatically retracts if no input is given

   # Pins
   - Properties:
     - position: Vector (x, y coordinates)
   - Initial state:
     - One pin at the center-top of the screen (cord's initial anchor)
   - Shape: small rectangle
   - Color: blue
   - Appearance rules:
     - New pins spawn at the top of the screen at regular scrolling distances
     - Pins are randomly positioned horizontally
   - Scrolling:
     - All pins move downward to position the anchored pin near the screen's bottom
     - Pins that move off-screen are removed
   - Collision events:
     - If the cord collides with a pin, that pin becomes the new anchor

5. Provide a skeleton JavaScript code structure with comments outlining the implementation of game rules. Include:
   - Variable definitions for game objects
   - update() function structure
   - Placeholders for object behavior implementation

   Example:

   ```javascript
   // Define variables for objects.
   // # Cord
   // - Properties: pinned pin, length, angle
   /** @type {{pinnedPin: {coordinate: Vector}, length: number, angle: number}} */
   let cord;
   const defaultCordLength = 7;
   // # Pins
   // - Properties:
   //   - position: Vector (x, y coordinates)
   /** @type { {coordinate: Vector}[]} */
   let pins;
   
   // Define variables for games.
   /** @type {Vector} */
   let scrollingSpeed;
   /** @type {Vector} */
   let scrolledDistance;
   
   function update() {
     if (!ticks) {
       // Set the initial state of the game.
       // # Pins
       // - Initial state:
       //   - One pin at the center-top of the screen (cord's initial anchor)
   	   
       // # Cord
       // - Initial state:
       //   - Attached to the initial pin at the center-top of the screen
       //   - length = defaultCordLength
       //   - angle = 0 (pointing rightwards)
       
       // Initialize all variables.
     }
     // Implement the rules of the objects.
     
     // # Cord:
     // - Shape: line
     // - Color: black
     // - One-button controls:
     //   - Press: Extend the cord (increase length)
     //   - Release: Retract the cord (decrease length)
     // - Behavior:
     //   - Continuously rotates around the anchor pin
     //   - Length changes based on button input
     //   - Automatically retracts if no input is given
     
     // # Pins
     // - Shape: small rectangle
     // - Color: blue
     // - Appearance rules:
     //   - New pins spawn at the top of the screen at regular scrolling distances
     //   - Pins are randomly positioned horizontally
     // - Scrolling:
     //   - All pins move downward to position the anchored pin near the screen's bottom
     //   - Pins that move off-screen are removed
     // - Collision events:
     //   - If the cord collides with a pin, that pin becomes the new anchor
   }
   ```

6. Study the crisp-game-lib library and example code:

   a. Examine crisp-game-lib.d.ts:
      - This file provides type definitions for the library's functions and objects.
      - Pay attention to the following key elements:
        - Input handling: use `input.isPressed`, `input.isJustPressed`, and `input.isJustReleased`
        - Drawing functions: `color()`, `rect()`, `box()`, `bar()`, `line()`, `arc()`, `text()`
        - Collision detection: Use the `Collision` type returned by drawing functions
        - Vector operations: Utilize the `Vector` interface and `vec()` function
        - Random number generation: `rnd()`, `rndi()`, `rnds()`
        - Math utilities: `clamp()`, `wrap()`, `PI`, `abs()`, `sin()`, `cos()`, etc.

   b. Analyze pinclimb.js:
      - This file demonstrates a complete game implementation using crisp-game-lib.
      - Note the structure and patterns used, such as:
        - Object definitions and their properties
        - The `update()` function structure
        - How scrolling is implemented
        - Collision detection and handling
        - Use of drawing functions

7. Implement the game logic using the crisp-game-lib library, translating each comment in the skeleton into functional JavaScript. Key points:
   - Proper use of crisp-game-lib functions, define game objects and structure your update() function as demonstrated in pinclimb.js
   - Use `isColliding` for simultaneous drawing and collision detection:
     ```javascript
     color("blue");
     if (box(player.pos, player.size).isColliding.rect.red) {
       // Handle collision with drawn red rectangles
     }
     ```
   - Implement scrolling with a scrollSpeed Vector:
     ```javascript
     let scrollSpeed = vec(0, 1);
     // In update():
     obstacle.pos.y += scrollSpeed.y;
     ```
   - Use `vec()` for Vector copying:
     ```javascript
     let newPos = vec(oldPos);
     ```
   - Utilize `clamp()` for value limiting:
     ```javascript
     player.pos.x = clamp(player.pos.x, 0, 100);
     ```
   - Accurate implementation of game rules
   - Clear and concise code structure
   - Retention of descriptive comments

Remember:
- Prioritize simplicity and innovation in game mechanics
- Design rules that are straightforward to implement
- Create intuitive gameplay that's enjoyable with one-button control
- Balance challenge and accessibility for a fun player experience

Use artifacts for substantial content (>15 lines) that users might modify or reuse. Present artifacts in a structured format with appropriate type and identifier attributes.
